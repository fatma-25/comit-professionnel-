{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/appointments/settingsGenerator.js)\r\n * Version: 21.2.4\r\n * Build date: Mon Dec 06 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport dateUtils from \"../../../core/utils/date\";\nimport { isEmptyObject } from \"../../../core/utils/type\";\nimport { extend } from \"../../../core/utils/extend\";\nimport { getRecurrenceProcessor } from \"../recurrence\";\nimport timeZoneUtils from \"../utils.timeZone\";\nimport { createResourcesTree, getDataAccessors, getGroupCount, getResourcesFromItem, getResourceTreeLeaves } from \"../resources/utils\";\nimport { createAppointmentAdapter } from \"../appointmentAdapter\";\nimport { CellPositionCalculator } from \"./cellPositionCalculator\";\nimport { ExpressionUtils } from \"../expressionUtils\";\nimport { isDateAndTimeView } from \"../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\nimport { createFormattedDateText } from \"./textUtils\";\nvar toMs = dateUtils.dateToMilliseconds;\nvar APPOINTMENT_DATE_TEXT_FORMAT = \"TIME\";\nexport class DateGeneratorBaseStrategy {\n  constructor(options) {\n    this.options = options;\n  }\n\n  get key() {\n    return this.options.key;\n  }\n\n  get rawAppointment() {\n    return this.options.rawAppointment;\n  }\n\n  get timeZoneCalculator() {\n    return this.options.timeZoneCalculator;\n  }\n\n  get viewDataProvider() {\n    return this.options.viewDataProvider;\n  }\n\n  get appointmentTakesAllDay() {\n    return this.options.appointmentTakesAllDay;\n  }\n\n  get supportAllDayRow() {\n    return this.options.supportAllDayRow;\n  }\n\n  get isAllDayRowAppointment() {\n    return this.options.isAllDayRowAppointment;\n  }\n\n  get timeZone() {\n    return this.options.timeZone;\n  }\n\n  get dateRange() {\n    return this.options.dateRange;\n  }\n\n  get firstDayOfWeek() {\n    return this.options.firstDayOfWeek;\n  }\n\n  get viewStartDayHour() {\n    return this.options.viewStartDayHour;\n  }\n\n  get viewEndDayHour() {\n    return this.options.viewEndDayHour;\n  }\n\n  get endViewDate() {\n    return this.options.endViewDate;\n  }\n\n  get viewType() {\n    return this.options.viewType;\n  }\n\n  get isGroupedByDate() {\n    return this.options.isGroupedByDate;\n  }\n\n  get isVerticalOrientation() {\n    return this.options.isVerticalOrientation;\n  }\n\n  get dataAccessors() {\n    return this.options.dataAccessors;\n  }\n\n  get loadedResources() {\n    return this.options.loadedResources;\n  }\n\n  get isDateAppointment() {\n    return !isDateAndTimeView(this.viewType) && this.appointmentTakesAllDay;\n  }\n\n  getIntervalDuration() {\n    return this.appointmentTakesAllDay ? this.options.allDayIntervalDuration : this.options.intervalDuration;\n  }\n\n  generate(appointmentAdapter) {\n    var itemResources = getResourcesFromItem(this.options.resources, this.dataAccessors.resources, this.rawAppointment);\n\n    var itemGroupIndices = this._getGroupIndices(itemResources);\n\n    var appointmentList = this._createAppointments(appointmentAdapter, itemGroupIndices);\n\n    appointmentList = this._getProcessedByAppointmentTimeZone(appointmentList, appointmentAdapter);\n\n    if (this._canProcessNotNativeTimezoneDates(appointmentAdapter)) {\n      appointmentList = this._getProcessedNotNativeTimezoneDates(appointmentList, appointmentAdapter);\n    }\n\n    var dateSettings = this._createGridAppointmentList(appointmentList, appointmentAdapter);\n\n    dateSettings = this._cropAppointmentsByStartDayHour(dateSettings, this.rawAppointment);\n    dateSettings = this._fillNormalizedEndDate(dateSettings, this.rawAppointment);\n\n    if (this._needSeparateLongParts()) {\n      dateSettings = this._separateLongParts(dateSettings, appointmentAdapter);\n    }\n\n    var {\n      isRecurrent: isRecurrent\n    } = appointmentAdapter;\n    return {\n      dateSettings: dateSettings,\n      itemGroupIndices: itemGroupIndices,\n      isRecurrent: isRecurrent\n    };\n  }\n\n  _getProcessedByAppointmentTimeZone(appointmentList, appointment) {\n    var hasAppointmentTimeZone = !isEmptyObject(appointment.startDateTimeZone) || !isEmptyObject(appointment.endDateTimeZone);\n\n    if (hasAppointmentTimeZone) {\n      var appointmentOffsets = {\n        startDate: this.timeZoneCalculator.getOffsets(appointment.startDate, appointment.startDateTimeZone),\n        endDate: this.timeZoneCalculator.getOffsets(appointment.endDate, appointment.endDateTimeZone)\n      };\n      appointmentList.forEach(a => {\n        var sourceOffsets_startDate = this.timeZoneCalculator.getOffsets(a.startDate, appointment.startDateTimeZone),\n            sourceOffsets_endDate = this.timeZoneCalculator.getOffsets(a.endDate, appointment.endDateTimeZone);\n        var startDateOffsetDiff = appointmentOffsets.startDate.appointment - sourceOffsets_startDate.appointment;\n        var endDateOffsetDiff = appointmentOffsets.endDate.appointment - sourceOffsets_endDate.appointment;\n\n        if (sourceOffsets_startDate.appointment !== sourceOffsets_startDate.common) {\n          a.startDate = new Date(a.startDate.getTime() + startDateOffsetDiff * toMs(\"hour\"));\n        }\n\n        if (sourceOffsets_endDate.appointment !== sourceOffsets_endDate.common) {\n          a.endDate = new Date(a.endDate.getTime() + endDateOffsetDiff * toMs(\"hour\"));\n        }\n      });\n    }\n\n    return appointmentList;\n  }\n\n  _createAppointments(appointment, groupIndices) {\n    var appointments = this._createRecurrenceAppointments(appointment, groupIndices);\n\n    if (!appointment.isRecurrent && 0 === appointments.length) {\n      appointments.push({\n        startDate: appointment.startDate,\n        endDate: appointment.endDate\n      });\n    }\n\n    appointments = appointments.map(item => {\n      var _item$endDate;\n\n      var resultEndTime = null === (_item$endDate = item.endDate) || void 0 === _item$endDate ? void 0 : _item$endDate.getTime();\n\n      if (item.startDate.getTime() === resultEndTime) {\n        item.endDate.setTime(resultEndTime + toMs(\"minute\"));\n      }\n\n      return _extends({}, item, {\n        exceptionDate: new Date(item.startDate)\n      });\n    });\n    return appointments;\n  }\n\n  _canProcessNotNativeTimezoneDates(appointment) {\n    var isTimeZoneSet = !isEmptyObject(this.timeZone);\n\n    if (!isTimeZoneSet) {\n      return false;\n    }\n\n    if (!appointment.isRecurrent) {\n      return false;\n    }\n\n    return !timeZoneUtils.isEqualLocalTimeZone(this.timeZone, appointment.startDate);\n  }\n\n  _getProcessedNotNativeDateIfCrossDST(date, offset) {\n    if (offset < 0) {\n      var newDate = new Date(date);\n      var newDateMinusOneHour = new Date(newDate);\n      newDateMinusOneHour.setHours(newDateMinusOneHour.getHours() - 1);\n      var newDateOffset = this.timeZoneCalculator.getOffsets(newDate).common;\n      var newDateMinusOneHourOffset = this.timeZoneCalculator.getOffsets(newDateMinusOneHour).common;\n\n      if (newDateOffset !== newDateMinusOneHourOffset) {\n        return 0;\n      }\n    }\n\n    return offset;\n  }\n\n  _getCommonOffset(date) {\n    return this.timeZoneCalculator.getOffsets(date).common;\n  }\n\n  _getProcessedNotNativeTimezoneDates(appointmentList, appointment) {\n    return appointmentList.map(item => {\n      var diffStartDateOffset = this._getCommonOffset(appointment.startDate) - this._getCommonOffset(item.startDate);\n\n      var diffEndDateOffset = this._getCommonOffset(appointment.endDate) - this._getCommonOffset(item.endDate);\n\n      if (0 === diffStartDateOffset && 0 === diffEndDateOffset) {\n        return item;\n      }\n\n      diffStartDateOffset = this._getProcessedNotNativeDateIfCrossDST(item.startDate, diffStartDateOffset);\n      diffEndDateOffset = this._getProcessedNotNativeDateIfCrossDST(item.endDate, diffEndDateOffset);\n      var newStartDate = new Date(item.startDate.getTime() + diffStartDateOffset * toMs(\"hour\"));\n      var newEndDate = new Date(item.endDate.getTime() + diffEndDateOffset * toMs(\"hour\"));\n      var testNewStartDate = this.timeZoneCalculator.createDate(newStartDate, {\n        path: \"toGrid\"\n      });\n      var testNewEndDate = this.timeZoneCalculator.createDate(newEndDate, {\n        path: \"toGrid\"\n      });\n\n      if (appointment.duration > testNewEndDate.getTime() - testNewStartDate.getTime()) {\n        newEndDate = new Date(newStartDate.getTime() + appointment.duration);\n      }\n\n      return _extends({}, item, {\n        startDate: newStartDate,\n        endDate: newEndDate,\n        exceptionDate: new Date(newStartDate)\n      });\n    });\n  }\n\n  _needSeparateLongParts() {\n    return this.isVerticalOrientation ? this.isGroupedByDate : this.isGroupedByDate && this.appointmentTakesAllDay;\n  }\n\n  normalizeEndDateByViewEnd(rawAppointment, endDate) {\n    var result = new Date(endDate.getTime());\n    var isAllDay = isDateAndTimeView(this.viewType) && this.appointmentTakesAllDay;\n\n    if (!isAllDay) {\n      var roundedEndViewDate = dateUtils.roundToHour(this.endViewDate);\n\n      if (result > roundedEndViewDate) {\n        result = roundedEndViewDate;\n      }\n    }\n\n    var endDayHour = this.viewEndDayHour;\n    var allDay = ExpressionUtils.getField(this.dataAccessors, \"allDay\", rawAppointment);\n    var currentViewEndTime = new Date(new Date(endDate.getTime()).setHours(endDayHour, 0, 0, 0));\n\n    if (result.getTime() > currentViewEndTime.getTime() || allDay && result.getHours() < endDayHour) {\n      result = currentViewEndTime;\n    }\n\n    return result;\n  }\n\n  _fillNormalizedEndDate(dateSettings, rawAppointment) {\n    return dateSettings.map(item => {\n      var {\n        endDate: endDate\n      } = item;\n      var normalizedEndDate = this.normalizeEndDateByViewEnd(rawAppointment, endDate);\n      return _extends({}, item, {\n        normalizedEndDate: normalizedEndDate\n      });\n    });\n  }\n\n  _separateLongParts(gridAppointmentList, appointmentAdapter) {\n    var result = [];\n    gridAppointmentList.forEach(gridAppointment => {\n      var maxDate = new Date(this.dateRange[1]);\n      var {\n        normalizedEndDate: endDateOfPart\n      } = gridAppointment;\n      var longStartDateParts = dateUtils.getDatesOfInterval(gridAppointment.startDate, endDateOfPart, {\n        milliseconds: this.getIntervalDuration(this.appointmentTakesAllDay)\n      });\n      var list = longStartDateParts.filter(startDatePart => new Date(startDatePart) < maxDate).map(date => {\n        var endDate = new Date(new Date(date).setMilliseconds(appointmentAdapter.duration));\n        var normalizedEndDate = this.normalizeEndDateByViewEnd(this.rawAppointment, endDate);\n        return {\n          startDate: date,\n          endDate: endDate,\n          normalizedEndDate: normalizedEndDate,\n          source: gridAppointment.source\n        };\n      });\n      result = result.concat(list);\n    });\n    return result;\n  }\n\n  _createGridAppointmentList(appointmentList, appointment) {\n    return appointmentList.map(source => {\n      var offsetDifference = appointment.startDate.getTimezoneOffset() - source.startDate.getTimezoneOffset();\n\n      if (0 !== offsetDifference && this._canProcessNotNativeTimezoneDates(appointment)) {\n        source.startDate = new Date(source.startDate.getTime() + offsetDifference * toMs(\"minute\"));\n        source.endDate = new Date(source.endDate.getTime() + offsetDifference * toMs(\"minute\"));\n        source.exceptionDate = new Date(source.startDate);\n      }\n\n      var startDate = this.timeZoneCalculator.createDate(source.startDate, {\n        path: \"toGrid\"\n      });\n      var endDate = this.timeZoneCalculator.createDate(source.endDate, {\n        path: \"toGrid\"\n      });\n      return {\n        startDate: startDate,\n        endDate: endDate,\n        source: source\n      };\n    });\n  }\n\n  _createExtremeRecurrenceDates() {\n    var startViewDate = this.appointmentTakesAllDay ? dateUtils.trimTime(this.dateRange[0]) : this.dateRange[0];\n    var endViewDateByEndDayHour = this.dateRange[1];\n\n    if (this.timeZone) {\n      startViewDate = this.timeZoneCalculator.createDate(startViewDate, {\n        path: \"fromGrid\"\n      });\n      endViewDateByEndDayHour = this.timeZoneCalculator.createDate(endViewDateByEndDayHour, {\n        path: \"fromGrid\"\n      });\n      var daylightOffset = timeZoneUtils.getDaylightOffsetInMs(startViewDate, endViewDateByEndDayHour);\n\n      if (daylightOffset) {\n        endViewDateByEndDayHour = new Date(endViewDateByEndDayHour.getTime() + daylightOffset);\n      }\n    }\n\n    return [startViewDate, endViewDateByEndDayHour];\n  }\n\n  _createRecurrenceOptions(appointment, groupIndex) {\n    var [minRecurrenceDate, maxRecurrenceDate] = this._createExtremeRecurrenceDates(groupIndex);\n\n    return {\n      rule: appointment.recurrenceRule,\n      exception: appointment.recurrenceException,\n      min: minRecurrenceDate,\n      max: maxRecurrenceDate,\n      firstDayOfWeek: this.firstDayOfWeek,\n      start: appointment.startDate,\n      end: appointment.endDate,\n      getPostProcessedException: date => {\n        if (isEmptyObject(this.timeZone) || timeZoneUtils.isEqualLocalTimeZone(this.timeZone, date)) {\n          return date;\n        }\n\n        var appointmentOffset = this.timeZoneCalculator.getOffsets(appointment.startDate).common;\n        var exceptionAppointmentOffset = this.timeZoneCalculator.getOffsets(date).common;\n        var diff = appointmentOffset - exceptionAppointmentOffset;\n        diff = this._getProcessedNotNativeDateIfCrossDST(date, diff);\n        return new Date(date.getTime() - diff * dateUtils.dateToMilliseconds(\"hour\"));\n      }\n    };\n  }\n\n  _createRecurrenceAppointments(appointment, groupIndices) {\n    var {\n      duration: duration\n    } = appointment;\n\n    var option = this._createRecurrenceOptions(appointment);\n\n    var generatedStartDates = getRecurrenceProcessor().generateDates(option);\n    return generatedStartDates.map(date => {\n      var utcDate = timeZoneUtils.createUTCDateWithLocalOffset(date);\n      utcDate.setTime(utcDate.getTime() + duration);\n      var endDate = timeZoneUtils.createDateFromUTCWithLocalOffset(utcDate);\n      return {\n        startDate: new Date(date),\n        endDate: endDate\n      };\n    });\n  }\n\n  _cropAppointmentsByStartDayHour(appointments, rawAppointment) {\n    return appointments.filter(appointment => {\n      var firstViewDate = this._getAppointmentFirstViewDate(appointment);\n\n      if (!firstViewDate) {\n        return false;\n      }\n\n      var startDayHour = this._getViewStartDayHour(firstViewDate);\n\n      var startDate = new Date(appointment.startDate);\n      appointment.startDate = this._getAppointmentResultDate({\n        appointment: appointment,\n        rawAppointment: rawAppointment,\n        startDate: startDate,\n        startDayHour: startDayHour,\n        firstViewDate: firstViewDate\n      });\n      return !this.isAllDayRowAppointment ? appointment.endDate > appointment.startDate : true;\n    });\n  }\n\n  _getViewStartDayHour() {\n    return this.viewStartDayHour;\n  }\n\n  _getAppointmentResultDate(options) {\n    var {\n      appointment: appointment,\n      startDayHour: startDayHour,\n      firstViewDate: firstViewDate\n    } = options;\n    var {\n      startDate: startDate\n    } = options;\n    var resultDate = new Date(appointment.startDate);\n\n    if (this.appointmentTakesAllDay) {\n      resultDate = dateUtils.normalizeDate(startDate, firstViewDate);\n    } else {\n      if (startDate < firstViewDate) {\n        startDate = firstViewDate;\n      }\n\n      resultDate = dateUtils.normalizeDate(appointment.startDate, startDate);\n    }\n\n    return !this.isDateAppointment ? dateUtils.roundDateByStartDayHour(resultDate, startDayHour) : resultDate;\n  }\n\n  _getAppointmentFirstViewDate(appointment) {\n    var groupIndex = appointment.source.groupIndex || 0;\n    var {\n      startDate: startDate,\n      endDate: endDate\n    } = appointment;\n    return this.viewDataProvider.findGroupCellStartDate(groupIndex, startDate, endDate, this.isAllDayRowAppointment, this.isDateAppointment);\n  }\n\n  _getGroupIndices(appointmentResources) {\n    var result = [];\n\n    if (appointmentResources && this.loadedResources.length) {\n      var tree = createResourcesTree(this.loadedResources);\n      result = getResourceTreeLeaves((field, action) => getDataAccessors(this.options.dataAccessors.resources, field, action), tree, appointmentResources);\n    }\n\n    return result;\n  }\n\n}\nexport class DateGeneratorVirtualStrategy extends DateGeneratorBaseStrategy {\n  get groupCount() {\n    return getGroupCount(this.loadedResources);\n  }\n\n  _createRecurrenceAppointments(appointment, groupIndices) {\n    var {\n      duration: duration\n    } = appointment;\n    var result = [];\n    var validGroupIndices = this.groupCount ? groupIndices : [0];\n    validGroupIndices.forEach(groupIndex => {\n      var option = this._createRecurrenceOptions(appointment, groupIndex);\n\n      var generatedStartDates = getRecurrenceProcessor().generateDates(option);\n      var recurrentInfo = generatedStartDates.map(date => {\n        var startDate = new Date(date);\n        var utcDate = timeZoneUtils.createUTCDateWithLocalOffset(date);\n        utcDate.setTime(utcDate.getTime() + duration);\n        var endDate = timeZoneUtils.createDateFromUTCWithLocalOffset(utcDate);\n        return {\n          startDate: startDate,\n          endDate: endDate,\n          groupIndex: groupIndex\n        };\n      });\n      result.push(...recurrentInfo);\n    });\n    return result;\n  }\n\n  _getViewStartDayHour(firstViewDate) {\n    return firstViewDate.getHours();\n  }\n\n  _updateGroupIndices(appointments, groupIndices) {\n    var result = [];\n    groupIndices.forEach(groupIndex => {\n      var groupStartDate = this.viewDataProvider.getGroupStartDate(groupIndex);\n\n      if (groupStartDate) {\n        appointments.forEach(appointment => {\n          var appointmentCopy = extend({}, appointment);\n          appointmentCopy.groupIndex = groupIndex;\n          result.push(appointmentCopy);\n        });\n      }\n    });\n    return result;\n  }\n\n  _getGroupIndices(resources) {\n    var _groupIndices;\n\n    var groupIndices = super._getGroupIndices(resources);\n\n    var viewDataGroupIndices = this.viewDataProvider.getGroupIndices();\n\n    if (!(null !== (_groupIndices = groupIndices) && void 0 !== _groupIndices && _groupIndices.length)) {\n      groupIndices = [0];\n    }\n\n    return groupIndices.filter(groupIndex => -1 !== viewDataGroupIndices.indexOf(groupIndex));\n  }\n\n  _createAppointments(appointment, groupIndices) {\n    var appointments = super._createAppointments(appointment, groupIndices);\n\n    return !appointment.isRecurrent ? this._updateGroupIndices(appointments, groupIndices) : appointments;\n  }\n\n}\nexport class AppointmentSettingsGenerator {\n  constructor(options) {\n    this.options = options;\n    this.appointmentAdapter = createAppointmentAdapter(this.rawAppointment, this.dataAccessors, this.timeZoneCalculator);\n  }\n\n  get rawAppointment() {\n    return this.options.rawAppointment;\n  }\n\n  get dataAccessors() {\n    return this.options.dataAccessors;\n  }\n\n  get timeZoneCalculator() {\n    return this.options.timeZoneCalculator;\n  }\n\n  get isAllDayRowAppointment() {\n    return this.options.appointmentTakesAllDay && this.options.supportAllDayRow;\n  }\n\n  get modelGroups() {\n    return this.options.modelGroups;\n  }\n\n  get dateSettingsStrategy() {\n    var options = _extends({}, this.options, {\n      isAllDayRowAppointment: this.isAllDayRowAppointment\n    });\n\n    return this.options.isVirtualScrolling ? new DateGeneratorVirtualStrategy(options) : new DateGeneratorBaseStrategy(options);\n  }\n\n  create() {\n    var {\n      dateSettings: dateSettings,\n      itemGroupIndices: itemGroupIndices,\n      isRecurrent: isRecurrent\n    } = this._generateDateSettings();\n\n    var cellPositions = this._calculateCellPositions(dateSettings, itemGroupIndices);\n\n    var result = this._prepareAppointmentInfos(dateSettings, cellPositions, isRecurrent);\n\n    return result;\n  }\n\n  _generateDateSettings() {\n    return this.dateSettingsStrategy.generate(this.appointmentAdapter);\n  }\n\n  _calculateCellPositions(dateSettings, itemGroupIndices) {\n    var cellPositionCalculator = new CellPositionCalculator(_extends({}, this.options, {\n      dateSettings: dateSettings\n    }));\n    return cellPositionCalculator.calculateCellPositions(itemGroupIndices, this.isAllDayRowAppointment, this.appointmentAdapter.isRecurrent);\n  }\n\n  _prepareAppointmentInfos(dateSettings, cellPositions, isRecurrent) {\n    var infos = [];\n    cellPositions.forEach(_ref => {\n      var {\n        coordinates: coordinates,\n        dateSettingIndex: dateSettingIndex\n      } = _ref;\n      var dateSetting = dateSettings[dateSettingIndex];\n\n      var dateText = this._getAppointmentDateText(dateSetting);\n\n      var info = {\n        appointment: dateSetting,\n        sourceAppointment: dateSetting.source,\n        dateText: dateText,\n        isRecurrent: isRecurrent\n      };\n\n      this._setResourceColor(info, coordinates.groupIndex);\n\n      infos.push(_extends({}, coordinates, {\n        info: info\n      }));\n    });\n    return infos;\n  }\n\n  _getAppointmentDateText(sourceAppointment) {\n    var {\n      startDate: startDate,\n      endDate: endDate,\n      allDay: allDay\n    } = sourceAppointment;\n    return createFormattedDateText({\n      startDate: startDate,\n      endDate: endDate,\n      allDay: allDay,\n      format: APPOINTMENT_DATE_TEXT_FORMAT\n    });\n  }\n\n  _setResourceColor(info, groupIndex) {\n    var appointmentConfig = {\n      itemData: this.rawAppointment,\n      groupIndex: groupIndex,\n      groups: this.modelGroups\n    };\n    this.options.getAppointmentColor(appointmentConfig).done(color => info.resourceColor = color);\n  }\n\n}","map":{"version":3,"sources":["/Users/fatmaamara/Desktop/projetetude/authentification-main/front-end/node_modules/devextreme/esm/ui/scheduler/appointments/settingsGenerator.js"],"names":["_extends","dateUtils","isEmptyObject","extend","getRecurrenceProcessor","timeZoneUtils","createResourcesTree","getDataAccessors","getGroupCount","getResourcesFromItem","getResourceTreeLeaves","createAppointmentAdapter","CellPositionCalculator","ExpressionUtils","isDateAndTimeView","createFormattedDateText","toMs","dateToMilliseconds","APPOINTMENT_DATE_TEXT_FORMAT","DateGeneratorBaseStrategy","constructor","options","key","rawAppointment","timeZoneCalculator","viewDataProvider","appointmentTakesAllDay","supportAllDayRow","isAllDayRowAppointment","timeZone","dateRange","firstDayOfWeek","viewStartDayHour","viewEndDayHour","endViewDate","viewType","isGroupedByDate","isVerticalOrientation","dataAccessors","loadedResources","isDateAppointment","getIntervalDuration","allDayIntervalDuration","intervalDuration","generate","appointmentAdapter","itemResources","resources","itemGroupIndices","_getGroupIndices","appointmentList","_createAppointments","_getProcessedByAppointmentTimeZone","_canProcessNotNativeTimezoneDates","_getProcessedNotNativeTimezoneDates","dateSettings","_createGridAppointmentList","_cropAppointmentsByStartDayHour","_fillNormalizedEndDate","_needSeparateLongParts","_separateLongParts","isRecurrent","appointment","hasAppointmentTimeZone","startDateTimeZone","endDateTimeZone","appointmentOffsets","startDate","getOffsets","endDate","forEach","a","sourceOffsets_startDate","sourceOffsets_endDate","startDateOffsetDiff","endDateOffsetDiff","common","Date","getTime","groupIndices","appointments","_createRecurrenceAppointments","length","push","map","item","_item$endDate","resultEndTime","setTime","exceptionDate","isTimeZoneSet","isEqualLocalTimeZone","_getProcessedNotNativeDateIfCrossDST","date","offset","newDate","newDateMinusOneHour","setHours","getHours","newDateOffset","newDateMinusOneHourOffset","_getCommonOffset","diffStartDateOffset","diffEndDateOffset","newStartDate","newEndDate","testNewStartDate","createDate","path","testNewEndDate","duration","normalizeEndDateByViewEnd","result","isAllDay","roundedEndViewDate","roundToHour","endDayHour","allDay","getField","currentViewEndTime","normalizedEndDate","gridAppointmentList","gridAppointment","maxDate","endDateOfPart","longStartDateParts","getDatesOfInterval","milliseconds","list","filter","startDatePart","setMilliseconds","source","concat","offsetDifference","getTimezoneOffset","_createExtremeRecurrenceDates","startViewDate","trimTime","endViewDateByEndDayHour","daylightOffset","getDaylightOffsetInMs","_createRecurrenceOptions","groupIndex","minRecurrenceDate","maxRecurrenceDate","rule","recurrenceRule","exception","recurrenceException","min","max","start","end","getPostProcessedException","appointmentOffset","exceptionAppointmentOffset","diff","option","generatedStartDates","generateDates","utcDate","createUTCDateWithLocalOffset","createDateFromUTCWithLocalOffset","firstViewDate","_getAppointmentFirstViewDate","startDayHour","_getViewStartDayHour","_getAppointmentResultDate","resultDate","normalizeDate","roundDateByStartDayHour","findGroupCellStartDate","appointmentResources","tree","field","action","DateGeneratorVirtualStrategy","groupCount","validGroupIndices","recurrentInfo","_updateGroupIndices","groupStartDate","getGroupStartDate","appointmentCopy","_groupIndices","viewDataGroupIndices","getGroupIndices","indexOf","AppointmentSettingsGenerator","modelGroups","dateSettingsStrategy","isVirtualScrolling","create","_generateDateSettings","cellPositions","_calculateCellPositions","_prepareAppointmentInfos","cellPositionCalculator","calculateCellPositions","infos","_ref","coordinates","dateSettingIndex","dateSetting","dateText","_getAppointmentDateText","info","sourceAppointment","_setResourceColor","format","appointmentConfig","itemData","groups","getAppointmentColor","done","color","resourceColor"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (esm/ui/scheduler/appointments/settingsGenerator.js)\r\n * Version: 21.2.4\r\n * Build date: Mon Dec 06 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\r\nimport dateUtils from \"../../../core/utils/date\";\r\nimport {\r\n    isEmptyObject\r\n} from \"../../../core/utils/type\";\r\nimport {\r\n    extend\r\n} from \"../../../core/utils/extend\";\r\nimport {\r\n    getRecurrenceProcessor\r\n} from \"../recurrence\";\r\nimport timeZoneUtils from \"../utils.timeZone\";\r\nimport {\r\n    createResourcesTree,\r\n    getDataAccessors,\r\n    getGroupCount,\r\n    getResourcesFromItem,\r\n    getResourceTreeLeaves\r\n} from \"../resources/utils\";\r\nimport {\r\n    createAppointmentAdapter\r\n} from \"../appointmentAdapter\";\r\nimport {\r\n    CellPositionCalculator\r\n} from \"./cellPositionCalculator\";\r\nimport {\r\n    ExpressionUtils\r\n} from \"../expressionUtils\";\r\nimport {\r\n    isDateAndTimeView\r\n} from \"../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\r\nimport {\r\n    createFormattedDateText\r\n} from \"./textUtils\";\r\nvar toMs = dateUtils.dateToMilliseconds;\r\nvar APPOINTMENT_DATE_TEXT_FORMAT = \"TIME\";\r\nexport class DateGeneratorBaseStrategy {\r\n    constructor(options) {\r\n        this.options = options\r\n    }\r\n    get key() {\r\n        return this.options.key\r\n    }\r\n    get rawAppointment() {\r\n        return this.options.rawAppointment\r\n    }\r\n    get timeZoneCalculator() {\r\n        return this.options.timeZoneCalculator\r\n    }\r\n    get viewDataProvider() {\r\n        return this.options.viewDataProvider\r\n    }\r\n    get appointmentTakesAllDay() {\r\n        return this.options.appointmentTakesAllDay\r\n    }\r\n    get supportAllDayRow() {\r\n        return this.options.supportAllDayRow\r\n    }\r\n    get isAllDayRowAppointment() {\r\n        return this.options.isAllDayRowAppointment\r\n    }\r\n    get timeZone() {\r\n        return this.options.timeZone\r\n    }\r\n    get dateRange() {\r\n        return this.options.dateRange\r\n    }\r\n    get firstDayOfWeek() {\r\n        return this.options.firstDayOfWeek\r\n    }\r\n    get viewStartDayHour() {\r\n        return this.options.viewStartDayHour\r\n    }\r\n    get viewEndDayHour() {\r\n        return this.options.viewEndDayHour\r\n    }\r\n    get endViewDate() {\r\n        return this.options.endViewDate\r\n    }\r\n    get viewType() {\r\n        return this.options.viewType\r\n    }\r\n    get isGroupedByDate() {\r\n        return this.options.isGroupedByDate\r\n    }\r\n    get isVerticalOrientation() {\r\n        return this.options.isVerticalOrientation\r\n    }\r\n    get dataAccessors() {\r\n        return this.options.dataAccessors\r\n    }\r\n    get loadedResources() {\r\n        return this.options.loadedResources\r\n    }\r\n    get isDateAppointment() {\r\n        return !isDateAndTimeView(this.viewType) && this.appointmentTakesAllDay\r\n    }\r\n    getIntervalDuration() {\r\n        return this.appointmentTakesAllDay ? this.options.allDayIntervalDuration : this.options.intervalDuration\r\n    }\r\n    generate(appointmentAdapter) {\r\n        var itemResources = getResourcesFromItem(this.options.resources, this.dataAccessors.resources, this.rawAppointment);\r\n        var itemGroupIndices = this._getGroupIndices(itemResources);\r\n        var appointmentList = this._createAppointments(appointmentAdapter, itemGroupIndices);\r\n        appointmentList = this._getProcessedByAppointmentTimeZone(appointmentList, appointmentAdapter);\r\n        if (this._canProcessNotNativeTimezoneDates(appointmentAdapter)) {\r\n            appointmentList = this._getProcessedNotNativeTimezoneDates(appointmentList, appointmentAdapter)\r\n        }\r\n        var dateSettings = this._createGridAppointmentList(appointmentList, appointmentAdapter);\r\n        dateSettings = this._cropAppointmentsByStartDayHour(dateSettings, this.rawAppointment);\r\n        dateSettings = this._fillNormalizedEndDate(dateSettings, this.rawAppointment);\r\n        if (this._needSeparateLongParts()) {\r\n            dateSettings = this._separateLongParts(dateSettings, appointmentAdapter)\r\n        }\r\n        var {\r\n            isRecurrent: isRecurrent\r\n        } = appointmentAdapter;\r\n        return {\r\n            dateSettings: dateSettings,\r\n            itemGroupIndices: itemGroupIndices,\r\n            isRecurrent: isRecurrent\r\n        }\r\n    }\r\n    _getProcessedByAppointmentTimeZone(appointmentList, appointment) {\r\n        var hasAppointmentTimeZone = !isEmptyObject(appointment.startDateTimeZone) || !isEmptyObject(appointment.endDateTimeZone);\r\n        if (hasAppointmentTimeZone) {\r\n            var appointmentOffsets = {\r\n                startDate: this.timeZoneCalculator.getOffsets(appointment.startDate, appointment.startDateTimeZone),\r\n                endDate: this.timeZoneCalculator.getOffsets(appointment.endDate, appointment.endDateTimeZone)\r\n            };\r\n            appointmentList.forEach(a => {\r\n                var sourceOffsets_startDate = this.timeZoneCalculator.getOffsets(a.startDate, appointment.startDateTimeZone),\r\n                    sourceOffsets_endDate = this.timeZoneCalculator.getOffsets(a.endDate, appointment.endDateTimeZone);\r\n                var startDateOffsetDiff = appointmentOffsets.startDate.appointment - sourceOffsets_startDate.appointment;\r\n                var endDateOffsetDiff = appointmentOffsets.endDate.appointment - sourceOffsets_endDate.appointment;\r\n                if (sourceOffsets_startDate.appointment !== sourceOffsets_startDate.common) {\r\n                    a.startDate = new Date(a.startDate.getTime() + startDateOffsetDiff * toMs(\"hour\"))\r\n                }\r\n                if (sourceOffsets_endDate.appointment !== sourceOffsets_endDate.common) {\r\n                    a.endDate = new Date(a.endDate.getTime() + endDateOffsetDiff * toMs(\"hour\"))\r\n                }\r\n            })\r\n        }\r\n        return appointmentList\r\n    }\r\n    _createAppointments(appointment, groupIndices) {\r\n        var appointments = this._createRecurrenceAppointments(appointment, groupIndices);\r\n        if (!appointment.isRecurrent && 0 === appointments.length) {\r\n            appointments.push({\r\n                startDate: appointment.startDate,\r\n                endDate: appointment.endDate\r\n            })\r\n        }\r\n        appointments = appointments.map(item => {\r\n            var _item$endDate;\r\n            var resultEndTime = null === (_item$endDate = item.endDate) || void 0 === _item$endDate ? void 0 : _item$endDate.getTime();\r\n            if (item.startDate.getTime() === resultEndTime) {\r\n                item.endDate.setTime(resultEndTime + toMs(\"minute\"))\r\n            }\r\n            return _extends({}, item, {\r\n                exceptionDate: new Date(item.startDate)\r\n            })\r\n        });\r\n        return appointments\r\n    }\r\n    _canProcessNotNativeTimezoneDates(appointment) {\r\n        var isTimeZoneSet = !isEmptyObject(this.timeZone);\r\n        if (!isTimeZoneSet) {\r\n            return false\r\n        }\r\n        if (!appointment.isRecurrent) {\r\n            return false\r\n        }\r\n        return !timeZoneUtils.isEqualLocalTimeZone(this.timeZone, appointment.startDate)\r\n    }\r\n    _getProcessedNotNativeDateIfCrossDST(date, offset) {\r\n        if (offset < 0) {\r\n            var newDate = new Date(date);\r\n            var newDateMinusOneHour = new Date(newDate);\r\n            newDateMinusOneHour.setHours(newDateMinusOneHour.getHours() - 1);\r\n            var newDateOffset = this.timeZoneCalculator.getOffsets(newDate).common;\r\n            var newDateMinusOneHourOffset = this.timeZoneCalculator.getOffsets(newDateMinusOneHour).common;\r\n            if (newDateOffset !== newDateMinusOneHourOffset) {\r\n                return 0\r\n            }\r\n        }\r\n        return offset\r\n    }\r\n    _getCommonOffset(date) {\r\n        return this.timeZoneCalculator.getOffsets(date).common\r\n    }\r\n    _getProcessedNotNativeTimezoneDates(appointmentList, appointment) {\r\n        return appointmentList.map(item => {\r\n            var diffStartDateOffset = this._getCommonOffset(appointment.startDate) - this._getCommonOffset(item.startDate);\r\n            var diffEndDateOffset = this._getCommonOffset(appointment.endDate) - this._getCommonOffset(item.endDate);\r\n            if (0 === diffStartDateOffset && 0 === diffEndDateOffset) {\r\n                return item\r\n            }\r\n            diffStartDateOffset = this._getProcessedNotNativeDateIfCrossDST(item.startDate, diffStartDateOffset);\r\n            diffEndDateOffset = this._getProcessedNotNativeDateIfCrossDST(item.endDate, diffEndDateOffset);\r\n            var newStartDate = new Date(item.startDate.getTime() + diffStartDateOffset * toMs(\"hour\"));\r\n            var newEndDate = new Date(item.endDate.getTime() + diffEndDateOffset * toMs(\"hour\"));\r\n            var testNewStartDate = this.timeZoneCalculator.createDate(newStartDate, {\r\n                path: \"toGrid\"\r\n            });\r\n            var testNewEndDate = this.timeZoneCalculator.createDate(newEndDate, {\r\n                path: \"toGrid\"\r\n            });\r\n            if (appointment.duration > testNewEndDate.getTime() - testNewStartDate.getTime()) {\r\n                newEndDate = new Date(newStartDate.getTime() + appointment.duration)\r\n            }\r\n            return _extends({}, item, {\r\n                startDate: newStartDate,\r\n                endDate: newEndDate,\r\n                exceptionDate: new Date(newStartDate)\r\n            })\r\n        })\r\n    }\r\n    _needSeparateLongParts() {\r\n        return this.isVerticalOrientation ? this.isGroupedByDate : this.isGroupedByDate && this.appointmentTakesAllDay\r\n    }\r\n    normalizeEndDateByViewEnd(rawAppointment, endDate) {\r\n        var result = new Date(endDate.getTime());\r\n        var isAllDay = isDateAndTimeView(this.viewType) && this.appointmentTakesAllDay;\r\n        if (!isAllDay) {\r\n            var roundedEndViewDate = dateUtils.roundToHour(this.endViewDate);\r\n            if (result > roundedEndViewDate) {\r\n                result = roundedEndViewDate\r\n            }\r\n        }\r\n        var endDayHour = this.viewEndDayHour;\r\n        var allDay = ExpressionUtils.getField(this.dataAccessors, \"allDay\", rawAppointment);\r\n        var currentViewEndTime = new Date(new Date(endDate.getTime()).setHours(endDayHour, 0, 0, 0));\r\n        if (result.getTime() > currentViewEndTime.getTime() || allDay && result.getHours() < endDayHour) {\r\n            result = currentViewEndTime\r\n        }\r\n        return result\r\n    }\r\n    _fillNormalizedEndDate(dateSettings, rawAppointment) {\r\n        return dateSettings.map(item => {\r\n            var {\r\n                endDate: endDate\r\n            } = item;\r\n            var normalizedEndDate = this.normalizeEndDateByViewEnd(rawAppointment, endDate);\r\n            return _extends({}, item, {\r\n                normalizedEndDate: normalizedEndDate\r\n            })\r\n        })\r\n    }\r\n    _separateLongParts(gridAppointmentList, appointmentAdapter) {\r\n        var result = [];\r\n        gridAppointmentList.forEach(gridAppointment => {\r\n            var maxDate = new Date(this.dateRange[1]);\r\n            var {\r\n                normalizedEndDate: endDateOfPart\r\n            } = gridAppointment;\r\n            var longStartDateParts = dateUtils.getDatesOfInterval(gridAppointment.startDate, endDateOfPart, {\r\n                milliseconds: this.getIntervalDuration(this.appointmentTakesAllDay)\r\n            });\r\n            var list = longStartDateParts.filter(startDatePart => new Date(startDatePart) < maxDate).map(date => {\r\n                var endDate = new Date(new Date(date).setMilliseconds(appointmentAdapter.duration));\r\n                var normalizedEndDate = this.normalizeEndDateByViewEnd(this.rawAppointment, endDate);\r\n                return {\r\n                    startDate: date,\r\n                    endDate: endDate,\r\n                    normalizedEndDate: normalizedEndDate,\r\n                    source: gridAppointment.source\r\n                }\r\n            });\r\n            result = result.concat(list)\r\n        });\r\n        return result\r\n    }\r\n    _createGridAppointmentList(appointmentList, appointment) {\r\n        return appointmentList.map(source => {\r\n            var offsetDifference = appointment.startDate.getTimezoneOffset() - source.startDate.getTimezoneOffset();\r\n            if (0 !== offsetDifference && this._canProcessNotNativeTimezoneDates(appointment)) {\r\n                source.startDate = new Date(source.startDate.getTime() + offsetDifference * toMs(\"minute\"));\r\n                source.endDate = new Date(source.endDate.getTime() + offsetDifference * toMs(\"minute\"));\r\n                source.exceptionDate = new Date(source.startDate)\r\n            }\r\n            var startDate = this.timeZoneCalculator.createDate(source.startDate, {\r\n                path: \"toGrid\"\r\n            });\r\n            var endDate = this.timeZoneCalculator.createDate(source.endDate, {\r\n                path: \"toGrid\"\r\n            });\r\n            return {\r\n                startDate: startDate,\r\n                endDate: endDate,\r\n                source: source\r\n            }\r\n        })\r\n    }\r\n    _createExtremeRecurrenceDates() {\r\n        var startViewDate = this.appointmentTakesAllDay ? dateUtils.trimTime(this.dateRange[0]) : this.dateRange[0];\r\n        var endViewDateByEndDayHour = this.dateRange[1];\r\n        if (this.timeZone) {\r\n            startViewDate = this.timeZoneCalculator.createDate(startViewDate, {\r\n                path: \"fromGrid\"\r\n            });\r\n            endViewDateByEndDayHour = this.timeZoneCalculator.createDate(endViewDateByEndDayHour, {\r\n                path: \"fromGrid\"\r\n            });\r\n            var daylightOffset = timeZoneUtils.getDaylightOffsetInMs(startViewDate, endViewDateByEndDayHour);\r\n            if (daylightOffset) {\r\n                endViewDateByEndDayHour = new Date(endViewDateByEndDayHour.getTime() + daylightOffset)\r\n            }\r\n        }\r\n        return [startViewDate, endViewDateByEndDayHour]\r\n    }\r\n    _createRecurrenceOptions(appointment, groupIndex) {\r\n        var [minRecurrenceDate, maxRecurrenceDate] = this._createExtremeRecurrenceDates(groupIndex);\r\n        return {\r\n            rule: appointment.recurrenceRule,\r\n            exception: appointment.recurrenceException,\r\n            min: minRecurrenceDate,\r\n            max: maxRecurrenceDate,\r\n            firstDayOfWeek: this.firstDayOfWeek,\r\n            start: appointment.startDate,\r\n            end: appointment.endDate,\r\n            getPostProcessedException: date => {\r\n                if (isEmptyObject(this.timeZone) || timeZoneUtils.isEqualLocalTimeZone(this.timeZone, date)) {\r\n                    return date\r\n                }\r\n                var appointmentOffset = this.timeZoneCalculator.getOffsets(appointment.startDate).common;\r\n                var exceptionAppointmentOffset = this.timeZoneCalculator.getOffsets(date).common;\r\n                var diff = appointmentOffset - exceptionAppointmentOffset;\r\n                diff = this._getProcessedNotNativeDateIfCrossDST(date, diff);\r\n                return new Date(date.getTime() - diff * dateUtils.dateToMilliseconds(\"hour\"))\r\n            }\r\n        }\r\n    }\r\n    _createRecurrenceAppointments(appointment, groupIndices) {\r\n        var {\r\n            duration: duration\r\n        } = appointment;\r\n        var option = this._createRecurrenceOptions(appointment);\r\n        var generatedStartDates = getRecurrenceProcessor().generateDates(option);\r\n        return generatedStartDates.map(date => {\r\n            var utcDate = timeZoneUtils.createUTCDateWithLocalOffset(date);\r\n            utcDate.setTime(utcDate.getTime() + duration);\r\n            var endDate = timeZoneUtils.createDateFromUTCWithLocalOffset(utcDate);\r\n            return {\r\n                startDate: new Date(date),\r\n                endDate: endDate\r\n            }\r\n        })\r\n    }\r\n    _cropAppointmentsByStartDayHour(appointments, rawAppointment) {\r\n        return appointments.filter(appointment => {\r\n            var firstViewDate = this._getAppointmentFirstViewDate(appointment);\r\n            if (!firstViewDate) {\r\n                return false\r\n            }\r\n            var startDayHour = this._getViewStartDayHour(firstViewDate);\r\n            var startDate = new Date(appointment.startDate);\r\n            appointment.startDate = this._getAppointmentResultDate({\r\n                appointment: appointment,\r\n                rawAppointment: rawAppointment,\r\n                startDate: startDate,\r\n                startDayHour: startDayHour,\r\n                firstViewDate: firstViewDate\r\n            });\r\n            return !this.isAllDayRowAppointment ? appointment.endDate > appointment.startDate : true\r\n        })\r\n    }\r\n    _getViewStartDayHour() {\r\n        return this.viewStartDayHour\r\n    }\r\n    _getAppointmentResultDate(options) {\r\n        var {\r\n            appointment: appointment,\r\n            startDayHour: startDayHour,\r\n            firstViewDate: firstViewDate\r\n        } = options;\r\n        var {\r\n            startDate: startDate\r\n        } = options;\r\n        var resultDate = new Date(appointment.startDate);\r\n        if (this.appointmentTakesAllDay) {\r\n            resultDate = dateUtils.normalizeDate(startDate, firstViewDate)\r\n        } else {\r\n            if (startDate < firstViewDate) {\r\n                startDate = firstViewDate\r\n            }\r\n            resultDate = dateUtils.normalizeDate(appointment.startDate, startDate)\r\n        }\r\n        return !this.isDateAppointment ? dateUtils.roundDateByStartDayHour(resultDate, startDayHour) : resultDate\r\n    }\r\n    _getAppointmentFirstViewDate(appointment) {\r\n        var groupIndex = appointment.source.groupIndex || 0;\r\n        var {\r\n            startDate: startDate,\r\n            endDate: endDate\r\n        } = appointment;\r\n        return this.viewDataProvider.findGroupCellStartDate(groupIndex, startDate, endDate, this.isAllDayRowAppointment, this.isDateAppointment)\r\n    }\r\n    _getGroupIndices(appointmentResources) {\r\n        var result = [];\r\n        if (appointmentResources && this.loadedResources.length) {\r\n            var tree = createResourcesTree(this.loadedResources);\r\n            result = getResourceTreeLeaves((field, action) => getDataAccessors(this.options.dataAccessors.resources, field, action), tree, appointmentResources)\r\n        }\r\n        return result\r\n    }\r\n}\r\nexport class DateGeneratorVirtualStrategy extends DateGeneratorBaseStrategy {\r\n    get groupCount() {\r\n        return getGroupCount(this.loadedResources)\r\n    }\r\n    _createRecurrenceAppointments(appointment, groupIndices) {\r\n        var {\r\n            duration: duration\r\n        } = appointment;\r\n        var result = [];\r\n        var validGroupIndices = this.groupCount ? groupIndices : [0];\r\n        validGroupIndices.forEach(groupIndex => {\r\n            var option = this._createRecurrenceOptions(appointment, groupIndex);\r\n            var generatedStartDates = getRecurrenceProcessor().generateDates(option);\r\n            var recurrentInfo = generatedStartDates.map(date => {\r\n                var startDate = new Date(date);\r\n                var utcDate = timeZoneUtils.createUTCDateWithLocalOffset(date);\r\n                utcDate.setTime(utcDate.getTime() + duration);\r\n                var endDate = timeZoneUtils.createDateFromUTCWithLocalOffset(utcDate);\r\n                return {\r\n                    startDate: startDate,\r\n                    endDate: endDate,\r\n                    groupIndex: groupIndex\r\n                }\r\n            });\r\n            result.push(...recurrentInfo)\r\n        });\r\n        return result\r\n    }\r\n    _getViewStartDayHour(firstViewDate) {\r\n        return firstViewDate.getHours()\r\n    }\r\n    _updateGroupIndices(appointments, groupIndices) {\r\n        var result = [];\r\n        groupIndices.forEach(groupIndex => {\r\n            var groupStartDate = this.viewDataProvider.getGroupStartDate(groupIndex);\r\n            if (groupStartDate) {\r\n                appointments.forEach(appointment => {\r\n                    var appointmentCopy = extend({}, appointment);\r\n                    appointmentCopy.groupIndex = groupIndex;\r\n                    result.push(appointmentCopy)\r\n                })\r\n            }\r\n        });\r\n        return result\r\n    }\r\n    _getGroupIndices(resources) {\r\n        var _groupIndices;\r\n        var groupIndices = super._getGroupIndices(resources);\r\n        var viewDataGroupIndices = this.viewDataProvider.getGroupIndices();\r\n        if (!(null !== (_groupIndices = groupIndices) && void 0 !== _groupIndices && _groupIndices.length)) {\r\n            groupIndices = [0]\r\n        }\r\n        return groupIndices.filter(groupIndex => -1 !== viewDataGroupIndices.indexOf(groupIndex))\r\n    }\r\n    _createAppointments(appointment, groupIndices) {\r\n        var appointments = super._createAppointments(appointment, groupIndices);\r\n        return !appointment.isRecurrent ? this._updateGroupIndices(appointments, groupIndices) : appointments\r\n    }\r\n}\r\nexport class AppointmentSettingsGenerator {\r\n    constructor(options) {\r\n        this.options = options;\r\n        this.appointmentAdapter = createAppointmentAdapter(this.rawAppointment, this.dataAccessors, this.timeZoneCalculator)\r\n    }\r\n    get rawAppointment() {\r\n        return this.options.rawAppointment\r\n    }\r\n    get dataAccessors() {\r\n        return this.options.dataAccessors\r\n    }\r\n    get timeZoneCalculator() {\r\n        return this.options.timeZoneCalculator\r\n    }\r\n    get isAllDayRowAppointment() {\r\n        return this.options.appointmentTakesAllDay && this.options.supportAllDayRow\r\n    }\r\n    get modelGroups() {\r\n        return this.options.modelGroups\r\n    }\r\n    get dateSettingsStrategy() {\r\n        var options = _extends({}, this.options, {\r\n            isAllDayRowAppointment: this.isAllDayRowAppointment\r\n        });\r\n        return this.options.isVirtualScrolling ? new DateGeneratorVirtualStrategy(options) : new DateGeneratorBaseStrategy(options)\r\n    }\r\n    create() {\r\n        var {\r\n            dateSettings: dateSettings,\r\n            itemGroupIndices: itemGroupIndices,\r\n            isRecurrent: isRecurrent\r\n        } = this._generateDateSettings();\r\n        var cellPositions = this._calculateCellPositions(dateSettings, itemGroupIndices);\r\n        var result = this._prepareAppointmentInfos(dateSettings, cellPositions, isRecurrent);\r\n        return result\r\n    }\r\n    _generateDateSettings() {\r\n        return this.dateSettingsStrategy.generate(this.appointmentAdapter)\r\n    }\r\n    _calculateCellPositions(dateSettings, itemGroupIndices) {\r\n        var cellPositionCalculator = new CellPositionCalculator(_extends({}, this.options, {\r\n            dateSettings: dateSettings\r\n        }));\r\n        return cellPositionCalculator.calculateCellPositions(itemGroupIndices, this.isAllDayRowAppointment, this.appointmentAdapter.isRecurrent)\r\n    }\r\n    _prepareAppointmentInfos(dateSettings, cellPositions, isRecurrent) {\r\n        var infos = [];\r\n        cellPositions.forEach(_ref => {\r\n            var {\r\n                coordinates: coordinates,\r\n                dateSettingIndex: dateSettingIndex\r\n            } = _ref;\r\n            var dateSetting = dateSettings[dateSettingIndex];\r\n            var dateText = this._getAppointmentDateText(dateSetting);\r\n            var info = {\r\n                appointment: dateSetting,\r\n                sourceAppointment: dateSetting.source,\r\n                dateText: dateText,\r\n                isRecurrent: isRecurrent\r\n            };\r\n            this._setResourceColor(info, coordinates.groupIndex);\r\n            infos.push(_extends({}, coordinates, {\r\n                info: info\r\n            }))\r\n        });\r\n        return infos\r\n    }\r\n    _getAppointmentDateText(sourceAppointment) {\r\n        var {\r\n            startDate: startDate,\r\n            endDate: endDate,\r\n            allDay: allDay\r\n        } = sourceAppointment;\r\n        return createFormattedDateText({\r\n            startDate: startDate,\r\n            endDate: endDate,\r\n            allDay: allDay,\r\n            format: APPOINTMENT_DATE_TEXT_FORMAT\r\n        })\r\n    }\r\n    _setResourceColor(info, groupIndex) {\r\n        var appointmentConfig = {\r\n            itemData: this.rawAppointment,\r\n            groupIndex: groupIndex,\r\n            groups: this.modelGroups\r\n        };\r\n        this.options.getAppointmentColor(appointmentConfig).done(color => info.resourceColor = color)\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}